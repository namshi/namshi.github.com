<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Tech @ Namshi.com]]></title>
  <link href="http://namshi.github.io/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://namshi.github.io/"/>
  <updated>2019-01-10T12:03:59+00:00</updated>
  <id>http://namshi.github.io/</id>
  <author>
    <name><![CDATA[Namshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[70% faster: rewriting the API that serves most of our traffic]]></title>
    <link href="http://namshi.github.io/blog/2017/05/28/rewriting-the-catalog-api/"/>
    <updated>2017-05-28T18:37:00+00:00</updated>
    <id>http://namshi.github.io/blog/2017/05/28/rewriting-the-catalog-api</id>
    <content type="html"><![CDATA[<p>At the beginning of 2017, we decided to revamp our catalog API which is one of the main parts of our infrastructure, as it‚Äôs the API that serves 60 to 70% of our overall traffic.</p>

<p><img class="center" src="/images/posts/catalog_api_main.png"></p>

<!-- more -->


<p>The catalog API provides a way to access our product offering. Broadly, it serves three categories of data:</p>

<ul>
<li>static pages (<a href="https://en-ae.namshi.com/women/">https://en-ae.namshi.com/women/</a>)</li>
<li>product details (<a href="https://en-ae.namshi.com/buy-anaya-patchwork-detail-kaftan-for-women-kaftans-263349.html">https://en-ae.namshi.com/buy-anaya-patchwork-detail-kaftan-for-women-kaftans-263349.html</a>)</li>
<li>product listing with search and suggestions (<a href="https://en-ae.namshi.com/women-clothing-arabian_clothing/">https://en-ae.namshi.com/women-clothing-arabian_clothing/</a>)</li>
</ul>


<p>Static pages, which are HTML files prepared by our content team, are stored on the file system. The product details are a set of product-specific information; the bulk of that information is stored in Redis so that we only have to go to the database to fetch stock availability for a particular product (as we want that to be real-time and extremely accurate). Product search and suggestions are powered by Solr, using keys based on product category, brand and so on.</p>

<p>We had two main goals for the rewrite: better performance and more ease of extensibility. In this post, we talk about how we managed to achieve those goals and our overall journey moving the products catalog API from our legacy PHP application to a Node.js microservice.</p>

<h2>Why did we decide to rewrite it?</h2>

<p>Our catalog API was built on top of our initial, chubby <a href="http://symfony.com/blog/going-soa-with-symfony2-a-year-and-a-half-down-the-road">API layer powered by Symfony2</a> ‚Äî a single repository hosting a few other functionalities of our architecture, like checkouts and customer profiles, all deployed as a single building block.</p>

<p>As the months went by, we decided to shift towards microservices and go for a rewrite because:</p>

<ul>
<li>a new, clean implementation is free from other dependencies, not tied to our shared API layer.</li>
<li>we could move away from PHP: as much as the language and platform have evolved since we started using it (we started with PHP 5.3, the PSR-0‚Ä¶those times!), we feel that other platforms provide a <a href="https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/">‚Äúnicer‚Äù development experience</a><a href="https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/">.</a></li>
<li>we‚Äôre very bullish on <a href="http://www.grpc.io/">gRPC</a> as the next-gen standard for communicating among microservices, and that wasn‚Äôt easy to support with our legacy implementation. Furthermore, even though that‚Äôs bound to change, you cannot build gRPC servers in PHP as only the client-side part is implemented.</li>
</ul>


<p>We could go on and mention a whole bunch of other reasons but, fundamentally, it all boils down to the fact that we needed to <strong>move away from our shared API layer</strong>. It served its purpose very well, allowing us to do <a href="https://en.wikipedia.org/wiki/Rapid_application_development">RAD</a> with very little overhead, unified deployments and shared dependencies. As the number of services grew larger and larger we decided to shift the complexity from the code (imagine maintaining an app with many responsibilities) to the architecture (imagine maintaining X apps with 1 responsibility): time to extract the beast!</p>

<p><em>(if you are interested in why we didn‚Äôt start with microservices to begin with, we‚Äôd recommend having a look at</em> <em><em><a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html"><em>Microservices: not a free lunch</em></a> </em>on High Scalability and</em> <a href="https://martinfowler.com/articles/microservice-trade-offs.html"><em>Microservice tradeoffs</em></a> <em>by Martin Fowler)</em></p>

<h2>Why NodeJs?</h2>

<p>We‚Äôve banked on JavaScript for quite some time, as we realized it‚Äôs the <em>lingua franca</em> that everyone‚Äôs able to speak. Software engineers get comfortable fairly quickly with it, and with ES6 and async/await (which we use through <code>node --harmony-async-await</code>), the language looks less of a weirdo üòÉ</p>

<p>Another reason to pick it was the fact that NodeJS is quite fast, especially for I/O heavy applications because it naturally handles I/O in a non-blocking manner, giving us a high throughput.</p>

<p>How fast? Well, <strong>fast enough</strong>.</p>

<p>We look at milliseconds, not microseconds, when we want to optimize the performance of our services, so having a platform that lets us efficiently schedule work <a href="https://bytearcher.com/articles/parallel-vs-concurrent/">concurrently</a> is all we need. The fact that we‚Äôre running in a ‚ÄúVM‚Äù (as opposed to the request-response-death model of traditional PHP deployments) lets us do some performance optimizations with objects we need to re-use across requests ‚Äî and we will explain those in detail later in this post. Let‚Äôs just say that we want a platform that can serve a sizable chunk of our HTTP requests <strong>within 20ms or less</strong>, and NodeJS does it very well.</p>

<p>What we think JS sucks at is that <strong>large codebases tend to become unmaintainable</strong>, so we‚Äôve made it our goal to <strong>never end up with a large JavaScript codebase</strong>. Most of our applications are microservices deployed on Docker containers, and re-writing good chunks of them won‚Äôt require more than a few weeks: we believe this leads to manageable JS applications, without needing Typescript, 100% test coverage &amp; the likes.</p>

<p>Our answer to how to grow a JS codebase? <strong>Don‚Äôt grow it, split it</strong>!</p>

<h2>Design</h2>

<p><strong>Architecture</strong></p>

<p><img class="center" src="/images/posts/catalog_api_architecture.png"></p>

<p>The architecture consists of a cluster of Node.js applications running within docker containers each of which are capped to 1 GB of RAM and 50% of 1 CPU core. We use Kubernetes to handle auto-scaling of our application. We have a Kubernetes configuration that handles automatically scaling our application once the CPU usage reaches 40% of 1 CPU core. We also have a Redis cluster (in <a href="https://aws.amazon.com/elasticache">ElastiCache</a>) alongside a <a href="http://tech.namshi.io/blog/2017/02/06/towards-high-availability-and-beyond/">highly available S</a><a href="http://tech.namshi.io/blog/2017/02/06/towards-high-availability-and-beyond/">olr cluster</a>.</p>

<p>Sidecar is a container running beside each instance of our catalog API, responsible for downloading the static HTML files from Amazon‚Äôs S3 when we want to update our static pages. It first downloads them to a shared volume and then notifies the catalog API by creating an update lock file: the application is always checking for the existence of this lock file and, once it finds it, it will clear the internally cached static files.  You can checkout our open source <a href="https://github.com/namshi/s3-sidecar">s3-sidecar</a>.</p>

<h2>The tools we use</h2>

<h3>Memoization</h3>

<p>A lot of our requests generate high number of cache misses, primarily because of small differences between requests, and we used to have a reverse proxy layer, powered by Varnish, that would serve cached results to around 20/25% of the requests. In order to simplify our architecture we decided to remove this layer (all in all, we didn‚Äôt have a high hit-rate) and use application level cache (through <a href="https://github.com/medikoo/memoizee">memoizee</a>) extensively, caching data used to service the request rather than caching the response itself.
For example, we preload some data which doesn‚Äôt change frequently, then save it in memory and update it at intervals ‚Äî this reduces the number of times we need to call external systems such as Redis, and speeds up the response time. Worth to note that we also use <code>memoizee</code> to cache our Solr request and, as much as we thought of putting Varnish in front of Solr, we eventually realized we didn‚Äôt need such complexity.</p>

<h3>Redis Pooling</h3>

<p>Instead of creating a new connection to Redis every time we need data, we created a connection pool to manage and reuse connection to Redis: the pool will keep a minimum number of open connections, and make sure we don‚Äôt exceed the maximum number of connections set in our configuration. This way we can keep less connections open, and scale them up fairly quickly when the app gets hammered by more traffic.</p>

<p>(<em>We used the</em> <a href="https://github.com/coopernurse/node-pool"><em>generic-pool</em></a> <em>module to avoid re-inventing the wheel üòÉ )</em></p>

<h3>Redis Client Proxy</h3>

<p>In order to centralize error, timeout and response handling when we interact with Redis, we added a proxy layer on top of the widely used <a href="https://github.com/NodeRedis/node_redis">redis module</a>, so that acquiring a connection, executing an operation and releasing the connection are abstracted away, with a promise-based interface: we released this as an open source <a href="https://github.com/namshi/node-redis-wrapper">redis wrapper</a> that contains both pooling connections and the proxying calls to redis.</p>

<h2>Going live</h2>

<p>You know how live deployment should be? <strong>Boring as hell</strong>, and we‚Äôve embraced this philosophy when rolling out this new API: the adrenaline of clicking the red button and rolling out the service at once is tempting, but the software engineer in you knows that it‚Äôs best to go live incrementally, fully prepared, aware of all the risks and ready to yawn as everything goes as expected.</p>

<p>Before going live, we decided to take a dual approach at benchmarking: first we would make sure that responses were ‚Äúfast enough‚Äù, then that they were ‚Äúscalable enough‚Äù.</p>

<h3>Being ‚Äúfast enough‚Äù</h3>

<p>It‚Äôs generally easy to think of the operations a piece of code is doing and say ‚Äúhey, this shouldn‚Äôt take more than 5 milliseconds‚Äù, and that‚Äôs what we exactly did: we simply rolled out to staging fairly early on and started doing some load testing with <a href="https://github.com/tsenart/vegeta">vegeta</a>.</p>

<p>After looking at the results coming from vegeta, we would then analyze them and figure out if they seemed reasonable to us: does <code>GET /some-content</code> involve calling Redis a couple times? Then it shouldn‚Äôt take more than 5 milliseconds. Does <code>GET /product1.html</code> need to fetch stock data from a slower DB? Then we should definitely be within 20/30 milliseconds. Is node taking more than 15 milliseconds on a particular route? Then we probably need to look at the way our code is organized, search for unneeded loops, and optimize.</p>

<p>NewRelic was instrumental during this phase, as we were able to see if we were hitting other layers too many times:</p>

<p><img class="center" src="/images/posts/catalog_api_newrelic.png"></p>

<p>Why is Redis taking 10 milliseconds? Are we hitting it multiple times? Can we batch requests together and instead of sending 3 <code>HGET</code> we simply issue 1 <code>HMGET</code>? Those were the kind of things we were looking at the time. By doing so, we optimized chunks of our code and were ready to take it to the next level.</p>

<blockquote><p><strong>A note on the computational cost of abstractions</strong></p>

<p>Lodash is a very popular JavaScript library that provides generic abstractions to solve various problems. One of them is the ‚Äú<a href="https://lodash.com/docs/4.17.4#pick">pick</a>‚Äù function which is used to pick a property from an object.</p>

<p>It turns out that this convenient abstraction comes at a cost.</p>

<p>Normally getting a property value from an object in JavaScript cost O(1) on the average case, but lodash‚Äôs pick‚Äôs implementation costs a O(n) on all cases where n is the length of properties within the object; in our case,
we were looping over hundreds of products and the delay in performance was not acceptable, so we opted to lose the abstraction provided by lodash in this regard.</p></blockquote>

<h3>Being ‚Äúscalable enough‚Äù</h3>

<p>Now, we‚Äôre no fools (or at least we like to believe so!), so we were sure that doing a bunch of ‚Äústatic‚Äù benchmarks with vegeta wouldn‚Äôt really tell us how the application would behave in production, where the amount of traffic and the variety of requests are very different.</p>

<p>We started testing the ‚Äúelasticity‚Äù of the app: take down all instances but one and start bombing it with incremental traffic, so we can observe how it reacts to an increase in traffic. We did so with a <a href="https://github.com/odino/quick-load-incremental">silly bash script</a> that would send X requests for a few minutes, give the service a break, then send 2X requests, 3X etc. This showed that the app could easily adapt to different levels of traffic, and we could focus on the next step.</p>

<p>Even though we now realized the app could take on a higher load without suffering too much, our tests were still too unrealistic: we were probing a few, known URLs, whereas live traffic would be spread across many different URLs ‚Äî products with 1 size, multiple sizes, products with many different related products, categories with very few products, categories with a plethora of products and so on. <strong>Replaying live traffic was a must</strong>.</p>

<p>Luckily, we discovered <a href="https://goreplay.org/">goreplay</a> a couple years back and fell in love with it. It lets you replay TCP traffic from one host to another one, without much overhead (it doesn‚Äôt act as a proxy, it just analyzes network packets and replays them, kind of a <a href="https://github.com/buger/goreplay/wiki/Capturing-and-replaying-traffic">tcpdump on steroids</a>). We then scaled up our staging cluster and replayed most of our live traffic to staging, observed the metric and let the replay run for hours and eventually days, until we were comfortable that the new app could sustain the live traffic very well.</p>

<p>We finally decided to deploy the application to production, but did not switch everything to the new API in one go as that could have brought down our entire website in case there were any issues that we hadn‚Äôt caught in the previous stages. So we went for the <strong>boring partial deployments</strong> approach: we kept the old app running and we started progressively switching traffic to the new app.</p>

<p>First, we picked the country with the least amount of traffic, then monitored the app, fixed the small bugs that would occur and repeated that same process for each one of the countries we serve until all the traffic was switched to the new app ‚Äî the whole process took about two weeks.
Yeah, it‚Äôs boring.</p>

<h2>Results</h2>

<p>Now comes the time to show what we were able to achieve in terms of performance improvement. In the old application, our average response time was around 82 milliseconds.</p>

<p><img class="center" src="/images/posts/catalog_api_results_1.png"></p>

<p>In the new application we managed to achieve an average response time of around 27 milliseconds ‚Äî that is a 67% performance improvement:</p>

<p><img class="center" src="/images/posts/catalog_api_results_2.png" title="" ></p>

<p>Since averages can be misleading let‚Äôs look at the percentile graph of the new application‚Äôs response time data.</p>

<p><img class="center" src="/images/posts/catalog_api_results_3.png"></p>

<p>What the graph above tells us is that 50% (red line) of our requests are served under 20 milliseconds and 95% (yellow line) of them are served below 100 milliseconds.</p>

<p>Using an histogram we also see the same pattern.</p>

<p><img class="center" src="/images/posts/catalog_api_results_4.png"></p>

<p>Basically, according to the histogram above, 20% of our requests are served within less than 10 milliseconds, and 53% of them are served within 20 milliseconds.</p>

<p>Now let‚Äôs look at the improvements in terms of resources utilization: as indicated in the graph below, our old PHP application used to consume about 25% of 2 CPU cores and 4 GB of memory. We went live with the new application on April 12, hence the considerable drop in resource consumption that you see in the graph.</p>

<p><img class="center" src="/images/posts/catalog_api_results_5.png"></p>

<p>The new application however as you can see in the graph uses way less resources. The graph below is for one of our host, which serves around 1000 rpm (requests per minute), and uses half a CPU (<a href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/">capped by k8s</a>) with a memory limit of 1 GB. You would agree  that‚Äôs a huge improvement on the old application!</p>

<p><img class="center" src="/images/posts/catalog_api_results_6.png"></p>

<h2>What‚Äôs Next?</h2>

<p>We are really happy with what we have achieved so far with the rewrite of the catalog&rsquo;s API. As we move forward, we would like to keep improving it ‚Äî as we do for all of our codebase ‚Äî by introducing appropriate tools and technologies. For example we would like to upgrade to node 8 so that we can take advantages of some nice features such as <code>async</code>  and <code>await</code> (without relying on harmony flags). We are also exploring the idea of using gRPC in order to improve how we do distributed systems overall.</p>

<p>If what you read here sounds interesting to you and you would like to build cool stuff with us, <a href="http://tech.namshi.io/blog/2017/03/09/currently-hiring-backend-mobile-developers-dubai/">please come join us</a>.</p>

<p><em>This article has been a joint effort between the backenders that revamped our
catalog API between February and April 2017: <a href="http://tech.namshi.io/team/#Ayham%20Alzoubi">Ayham</a> and <a href="http://tech.namshi.io/team/#Joe%20Jean">Joe</a>.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebuilding our mobile website: Express & React meet fun & profit]]></title>
    <link href="http://namshi.github.io/blog/2017/05/02/rebuilding-our-mobile-website/"/>
    <updated>2017-05-02T18:37:00+00:00</updated>
    <id>http://namshi.github.io/blog/2017/05/02/rebuilding-our-mobile-website</id>
    <content type="html"><![CDATA[<p>Late last year we decided to give our mobile website a new look, coupled with a new ‚Äúengine‚Äù in order to optimize our mobile experience on the web. Most of our users visit Namshi from mobile devices and we wanted to give them better usability, performance and overall smoother experience.</p>

<!-- more -->


<p>When we started approaching the mobile landscape, 4 years back, we decided to fully commit to an SPA that worked well but showed some limitations, namely the inability to perform server-side rendering, which was somewhat critical in terms of search engine optimization and first render: we solved the former by routing bots‚Äô traffic to our desktop website (a traditional server-side app), but the latter proved hard to solve, as the client would have to download our entire app before being able to understand what page and layout it should render. In the meantime, Google decided to roll the ‚Äú<em>mobile-friendly</em>‚Äù badge on their mobile SERPs, which forced us to look for alternatives.</p>

<p>A year and a half down the line, facing mixed results in terms of conversion rate and usability, we decided to review our implementation and build a small isomorphic app that would be able to render both on the client and the server, but this approach had 2 major flaws: first off, we didn‚Äôt look at neither our UX nor UI to figure out if there was anything we could do to make the user‚Äôs experience better and, second, we over-engineered our stack. Back then React just started garnering attention and, unsure if <em>that</em> would be the way the community would build ‚Äúfrontend‚Äù apps 3/5 years later, we decided to write a very small custom-made isomorphic framework that turned way more complicated than we originally thought.</p>

<p>At Namshi, we‚Äôre very big on simplicity and &ldquo;<em>back to the basics‚Äù</em> but, as you see, that‚Äôs also thanks to <strong>lessons we learned the hard way</strong>.</p>

<p>Flash-forward to Q4 2016, we looked at our mobile website and our metrics combined and decided it was time to completely re-think our approach: 2 of our engineers quickly hacked together a prototype within less than a week and, after discussing it with our PM team, we decided it was worth a shot.</p>

<p>The Falafel Project was born. Sounds like a joke but that‚Äôs what we actually called it :)</p>

<h2>Fundamental ideas</h2>

<p>The project kicked off by embracing 3 very important ideas:</p>

<ul>
<li>most of Namshi‚Äôs  traffic is served through our mobile apps (<a href="https://itunes.apple.com/us/app/namshi-online-fashion-shopping/id840127349?mt=8">iOS</a> + <a href="https://play.google.com/store/apps/details?id=com.namshi.android">Android</a>). We should probably <strong>mimic the app as much as possible</strong><strong>.</strong></li>
<li>The journey of the user is defined by very few, key components: landing pages, product listing pages, product detail pages, cart and checkout. We want to make sure we waste no time presenting these pages to the user, and <strong>server-side rendering</strong> gives that to us</li>
<li>If we want this webapp to look like it‚Äôs 2017, client-side interactions are unavoidable: <strong>picking React</strong>, given its rise in the frontend community and the fact that it‚Äôs a library, rather than a framework, was a no-brainer</li>
</ul>


<p><img class="center" src="/images/posts/web-mobile-demo.gif" title="" ></p>

<h2>Re-writing the styles</h2>

<p><img class="center" src="/images/posts/css-code.png" title="" ></p>

<p>We trashed the old css and rewrote it from scratch following the <a href="http://getbem.com/">BEM</a> way of doing things, which allowed us to separate styles per page and also have some of them shared between pages.
The total size of the minified styles was 18kb, now it is <strong>10kb:</strong> almost half of our css is gone!</p>

<h2>RTL styles</h2>

<p>It&rsquo;s always painful to handle direction in css, especially considering that things could have been much easier if <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties">logical properties</a> where introduced, but yet we still use the old techniques until we can fully dump rules overriding.</p>

<p>For example:</p>

<p><code>css
/**
 flex-start, flex-end logical properties will change according to the
 direction: rtl : ltr;
**/
.element {
 display: flex;
 align-items: flex-start;
 justify:-content: flex-start;
}
/**
 opposite to: text-align, css-transforms, floats, margins, paddings ..etc
 which we need to override manually.
**/
</code></p>

<p>We kept the arabic styles in separate files, i.e <code>list.scss / list-rtl.scss</code> where the <code>*-rtls.scss</code> will only override rules in the main file.
That worked for us really well and was a substantial increase in code maintainability.</p>

<h2>Enhanced UX leveraging on mobile browsers</h2>

<p>We took a decision to ditch SPAs in favor of lightning-fast server-side rendered pages.</p>

<p>Despite that, we took advantage of a very interesting feature on modern mobile browsers:
if you tap on a link, they kinda fade the newly painted page over it so if there are common visual components you won‚Äôt feel the page load.</p>

<p>Strange, right? Have a look:</p>

<div align="center">
<iframe width="276" height="500" src="https://www.youtube.com/embed/WIOe1ID3ocM" frameborder="0" allowfullscreen></iframe>
</div>


<p>So how we can use it for our own good?
We came up with idea of a ‚Äú<strong>Shadow Product‚Äù:</strong>  When a user taps on a product while on the catalog listing page, we delay the tap event for 10ms and we show a fake preview of what the next product page will look like. Simple and dirty, but looks great!</p>

<p>```js</p>

<pre><code>on('click', 'body', '.is-shadow-product', e =&gt; {      
 .... code that extracts content from clicked product
 this.setState({ data: data, show: true });      
 setTimeout(function () {        
   window.location.href = href;      
 }, 10);
})
</code></pre>

<p>```</p>

<p>The problem with this approach is that we need to handle the <a href="https://developer.mozilla.org/en-US/docs/Working_with_BFCache">back-forward cache</a> of some browsers:</p>

<p>```js</p>

<pre><code>// Prevent backforward cache in iOS devices
if(config.get('deviceOS') === 'iOS'){
  window.addEventListener('pagehide', function(e) {
    let shadowProduct = document.querySelector('.is-transitional');
    shadowProduct &amp;&amp; shadowProduct.classList.remove('is-transitional');
  });
}
</code></pre>

<p>```</p>

<h2>NO jQuery</h2>

<p>Late, but we eventually joined the party! We stripped jQuery off  80% of our pages and we replaced with some vanilla utilities like the following:</p>

<ul>
<li><strong>On</strong> :</li>
</ul>


<p>```js
  export function on(eventType, parent, selector, fn){</p>

<pre><code>let el = document.querySelector(parent);  
if(!el || !eventType || !selectorParent || !selector  || !fn ) {   
  return null;
}

el.addEventListener(eventType, function(e) {   
 .... logic to target the child on the event bubbling.
</code></pre>

<p>   })
  }, false);</p>

<p>```</p>

<ul>
<li><strong>Scroll to, Scroll To Top and Scroll To Bottom:</strong></li>
</ul>


<p>```js</p>

<pre><code>function animateScroll() {    
  var step = (dest - parent.scrollTop) /  steps--;    
  parent.scrollTop = parent.scrollTop + step;    
  if(steps === 0 ){      
    frame &amp;&amp;  cancelAnimationFrame &amp;&amp; cancelAnimationFrame(frame);       
    return    
  }     
 frame = requestAnimationFrame &amp;&amp;    
 requestAnimationFrame(animateScroll);   
}
</code></pre>

<p>```</p>

<hr />

<ul>
<li><strong>Image Carousel:</strong></li>
</ul>


<p>We crafted our own slider (<a href="https://medium.com/@MohamedAmin88/slim-slider-yet-another-javascript-slider-2f2069bb72e5">read the full story here</a>):</p>

<p><img class="center" src="/images/posts/slim-slider.gif" title="" ></p>

<h2>Low Fat React: Preact!</h2>

<p>Though we chose SSR, we were not building a static news website. You can imagine how much client side interactions an E-commerce mobile website has. Our previous mobile website was a tailor made isomorphic app, and we had lot of lessons learned from it. Moreover, performance was a key focus area for our new website, hence we kept some design decisions for all the client-side stuff. These includes:</p>

<ul>
<li>Our website should be interactive under 5s.

<ul>
<li>Should have a great rendering performance. Animations and transitions should be ~60FPS.</li>
<li>Total client-side scripts should be less than 100KB ( including any frameworks / library ).</li>
<li>Build re-usable client-side components.</li>
</ul>
</li>
</ul>


<p>By considering all the above, we wanted something lightweight and with good rendering performance.</p>

<p>We initially ruled jQuery out of the list and thought of creating all client-side components in vanilla js, however, we found that managing the UI state was bit hard with that approach. Moreover, we really liked the redux architecture and keeping a single store for managing the whole UI state.</p>

<p>React was the hottest choice for our expectations but, at the same time, we wanted a lightweight library. Then we came across <strong>Preact</strong>, a 3KB React alternative which offered the same API and great performance.</p>

<p>We built most of our components in Preact and re-used them across pages. Although we liked the redux architecture, we didn&rsquo;t really use Redux on our website. Instead, we built a micro-redux which has a global store for managing the whole UI state and is connected to all Preact components. This helped us to manage the UI state in a single store and synchronizing updates in every part of the page.</p>

<h2>Simplifying the DOM states</h2>

<p>Managing state is one of the crucial parts of  &ldquo;react like&rdquo; development, especially state shared between components (Shared State) can be difficult to manage. We have good libraries that achieves this efficiently &mdash; ie. <a href="http://redux.js.org/">Redux</a> and <a href="https://mobx.js.org/">Mobx</a> that we use on some of our SPAs.</p>

<p>In the new mobile website, our approach is a bit different because each page is SSR and we have very less shared state: we try to reduce client-side code to the minimum, to keep things simple and less bloated.</p>

<p>We have one store which is the single source of truth. To keep things simple every component has it own actions as part of the component, and we only focus on resolving all data into the store and the store automatically updates the state of the components. Unlike most redux implementations, where reducers are used to update the current state based on the actions,  every update always produces a ‚Äúnext state‚Äú without reference to the current state.</p>

<h2>Webpack, Code splitting and Preloading techniques</h2>

<p><img class="center" src="/images/posts/chunk-size.png" title="" ></p>

<p><strong>Code splitting: eat only what you need</strong></p>

<p>Code splitting was a crucial part for our website. Traditionally, we used to bundle all our JavaScript assets into one single file, and loaded it in every page. At that time it was a very performance-friendly approach, as the browser gets all the assets with a <strong>single HTTP request</strong>.</p>

<p>With HTTP2, things changed ‚Äî multiple round-trips are avoided by channelling multiple requests through a single connection. Knowing this, sending a large bundle (which includes code that&rsquo;s not needed in the current page) would negatively impact the page‚Äôs performance so we decided to split our code based on the routes ( different pages ).</p>

<p>We chose Webpack2 for bundling and code-splitting. As we said earlier, we generate js bundles ( aka chunks in webpack terminology ) for each page. We used Webpack&rsquo;s <a href="https://webpack.js.org/plugins/commons-chunk-plugin/">CommonsChunkPlugin</a> to generate a vendor bundle and common code shared between the page level bundles. This helped us to keep smallest JavaScript payload for each page. Furthermore, the vendor chunk and common chunk will change less frequently and can be cached by the browser for most requests, enabling faster transitions between pages.</p>

<p><strong>Reduce bundling and nested dependencies</strong></p>

<p>Webpack2 supports <a href="https://webpack.js.org/guides/tree-shaking/">Tree-shaking</a> out of the box, which helped us reduce the bundle size by ~20% by only including the required modules.</p>

<p>For example, we used some lodash utilities in our client-side code. Without Tree-shaking, the whole of lodash would have been imported into our bundles, thus the size would&rsquo;ve been much bigger. Webpack2 will instead generate the bundle only with the code that‚Äôs actually used.</p>

<p><strong>Preload, Prefetch</strong></p>

<p>We also took advantage of the latest browser features for attaining better page load speed. These includes the <code>dns-prefetch</code> for prefetching for resolving domain names, <code>link-preload</code> for loading the CSS and JS assets at the same time HTML is parsed. We also used <code>link-prerender</code> in our catalog listing page pagination to make the transition between pagination much faster.</p>

<p>Notice the <strong>Green Line</strong> ( which indicates the first paint ):</p>

<p><strong>Before</strong></p>

<p><img class="center" src="/images/posts/before-preload.png" title="" ></p>

<p><strong>After</strong></p>

<p><img class="center" src="/images/posts/after-preload.png" title="" ></p>

<h2>Goodbye good old image sprites</h2>

<p>Thanks to HTTP/2, making HTTP requests is cheaper than ever: multiplexing reduces the connection overhead as multiple requests can be tunneled through the same connections, and extended header compression (<a href="https://http2.github.io/http2-spec/compression.html">HPACK</a>) makes it so that those requests are lighter than ever.</p>

<p>This doesn‚Äôt mean sprites won‚Äôt give you any advantage: as always, making 10 HTTP requests instead of 1 is generally heavier, but with HTTP/2 you don‚Äôt ‚Äúfeel‚Äù it as much. Another argument <em>pro</em> sprites is that by combining images together we end up allowing the compression algorithm (ie. GZIP/DEFLATE) to better optimize the size of the final, combined image.</p>

<p>All in all, though, we eventually decided not to worry about these and live a less complicated life because:</p>

<ul>
<li>We generally bundle all required images into one sprite, whereas each page might just need 2/3 of them: this means that instead of downloading 100% of your images on the first page load we only require 20/30% of them</li>
<li>Maintaining sprites is no fun at all: if there‚Äôs a way to eliminate work and be <em>on par</em> with our previous implementation, then we‚Äôre definitely going to cut it short</li>
</ul>


<h2>Results</h2>

<p>Numbers, since we went live in mid-February, have been astounding. Even though web traffic is a small chunk of our overall traffic, it‚Äôs been way better than we could ever imagine:</p>

<ul>
<li><strong>conversion rate is up ~20%</strong>, meaning that the overall shopping experience is smoother (worth to note that some of the countries we serve have spikes in conversion of +30/70%)</li>
<li><strong>bounce rate is down 15%</strong>, which indicates that our first impression (load time, UI, etc) has definitely improved</li>
<li>the <strong>average time on page is up 50%</strong>, and the <strong>average session duration up 37%</strong>, meaning users enjoy spending time on the site way more than before</li>
<li>the <strong>average document load time &amp; average document interactive time are both down</strong> <strong>54%</strong> (4+ seconds vs 1.9), which means that‚Ä¶   ‚Ä¶well, we really screwed it up with the previous app :)</li>
</ul>


<p>Take this numbers with a pinch of salt, as we mentioned in the introduction of this article, we started from a very disadvantageous point ‚Äî the performance of the old mobile website was quite disappointing ‚Äî and, at the same time, Namshi grows and optimizes on a daily basis, so better numbers are expected regardless.</p>

<p>Last but not least, one for the server-side freaks.
In this article, we spoke a lot about frontend optimizations and the likes, but I want to share an image to show the performance of our server-side rendering process:</p>

<p><img class="center" src="/images/posts/web-mobile-results.png" title="" ></p>

<p>As you see, our <strong>average response time is around 40ms</strong> ‚Äî but you shouldn‚Äôt  care, as <a href="https://www.dynatrace.com/blog/why-averages-suck-and-percentiles-are-great/">averages make for a terrible KPI</a>.</p>

<p>Percentiles are really what you want to look at:</p>

<ul>
<li>the <strong>median is at around 25ms</strong>, meaning half of our requests are served within that time</li>
<li>the <strong>95th percentile is at around 120ms</strong>, which is still incredibly great, considering that the website fetches the data it displays from an internal API, and that involves an external HTTP call</li>
</ul>


<p>See you next time!</p>

<p><em>This article is a joint effort between the 3 frontend musketeers of Namshi:
<a href="http://tech.namshi.io/team/#Shidhin%20CR">Shidhin</a>, <a href="http://tech.namshi.io/team/#Mohamed%20Amin">Amin</a> and <a href="http://tech.namshi.io/team/#Gabriel%20Izebhigie">Gabriel</a></em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Newsletter #124]]></title>
    <link href="http://namshi.github.io/blog/2016/02/11/newsletter-number-124/"/>
    <updated>2016-02-11T12:38:00+00:00</updated>
    <id>http://namshi.github.io/blog/2016/02/11/newsletter-number-124</id>
    <content type="html"><![CDATA[<blockquote><p>Hi there!</p>

<p>Like everyone else we love the weekends too, look how happy the guys are:</p></blockquote>

<p><img class="center" src="/images/posts/ping-pong-happy.jpg"></p>

<blockquote><p>and here is your weekly quota of some interesting links</p>

<p>Enjoy!</p></blockquote>

<ul>
<li><p><a href="https://camjackson.net/post/9-things-every-reactjs-beginner-should-know">9 things every react.js beginner should know</a></p></li>
<li><p><a href="http://cleancoders.com/episode/clean-code-episode-1/view">clean coders videos</a></p></li>
<li><p><a href="https://github.com/codekitchen/dinghy?utm_content=bufferf938d">codekitchen/dinghy: faster, friendlier docker on os x</a></p></li>
<li><p><a href="https://blog.docker.com/2016/02/compose-1-6/?mkt_tok=3RkMMJWWfF9wsRonuqTMZKXonjHpfsX57uovUKe/lMI/0ER3fOvrPUfGjI4DScBkI+SLDwEYGJlv6SgFQ7LMMaZq1rgMXBk=">compose 1.6: new compose file for defining networks and volumes | docker blog</a></p></li>
</ul>


<!-- more -->


<ul>
<li><p><a href="http://www.paulund.co.uk/css-buttons-with-icons-but-no-images">css buttons with icons but no images</a></p></li>
<li><p><a href="http://www.desktopneo.com/">desktop neo ‚Äì rethinking the desktop interface for productivity.</a></p></li>
<li><p><a href="http://layer0.authentise.com/docker-4-useful-tips-you-may-not-know-about.html?utm_content=bufferbb9b6">docker: 4 useful tips, you may not know about</a></p></li>
<li><p><a href="http://verraes.net/2013/09/extract-till-you-drop/?utm_content=buffera385e">extract till you drop</a></p></li>
<li><p><a href="http://flif.info/">flif &ndash; free lossless image format</a></p></li>
<li><p><a href="http://blog.andrewray.me/flux-for-stupid-people/">flux for stupid people</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/18524652/how-to-use-javascript-object-defineproperty">how to use javascript object.defineproperty &ndash; stack overflow</a></p></li>
<li><p><a href="https://github.com/samccone/The-cost-of-transpiling-es2015-in-2016">investigating the overhead cost of compiled es2015</a></p></li>
<li><p><a href="http://brianchang.info/2016/02/01/issues-with-common-software-quality-metrics.html">issues with common software quality metrics</a></p></li>
<li><p><a href="http://javascriptair.com/">javascript air &ndash; the live broadcast podcast all about javascript</a></p></li>
<li><p><a href="http://jpnarowski.com/enterprise-react-redux-part-1/">launching an enterprise react and redux app</a></p></li>
<li><p><a href="http://peter.bourgon.org/blog/2016/02/07/logging-v-instrumentation.html">logging v. instrumentation</a></p></li>
<li><p><a href="http://www.iron.io/microcontainers-tiny-portable-containers/">microcontainers &ndash; tiny, portable docker containers</a></p></li>
<li><p><a href="https://blog.branch.io/mobile-app-developers-are-suffering">mobile app developers are suffering</a></p></li>
<li><p><a href="http://www.lukew.com/ff/entry.asp?1954">mobile web vs. native apps or why you want both</a></p></li>
<li><p><a href="https://github.com/mcollina/climem">monitor the memory consumption of your node process via cli</a></p></li>
<li><p><a href="http://brianchang.info/2016/01/17/object-oriented-developer.html">object-oriented developer</a></p></li>
<li><p><a href="https://github.com/unicorn-standard/starter-kit">project boilerplate using react, redux and uniloc</a></p></li>
<li><p><a href="https://toggl.com/developer-methods-infographic">software development methods explained with cars (infographic)</a></p></li>
<li><p><a href="http://vorpal.js.org/">vorpal &ndash; command line with js</a></p></li>
<li><p><a href="https://www.quora.com/What-do-programmers-at-Facebook-do-all-day">what do programmers at facebook do all day? &ndash; quora</a></p></li>
<li><p><a href="https://www.quora.com/Facebook-1/What-would-happen-to-worlds-economy-if-Facebook-suddenly-stopped-one-day">what would happen to world&rsquo;s economy if facebook suddenly stopped one day? &ndash; quora</a></p></li>
<li><p><a href="https://getpocket.com/a/read/1119332046">why progressive web apps are the future of web development</a></p></li>
<li><p><a href="http://www.yes-www.org/why-use-www/">why use www? ‚Äì www. is not deprecated</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Newsletter #123]]></title>
    <link href="http://namshi.github.io/blog/2016/01/28/newsletter-number-123/"/>
    <updated>2016-01-28T16:34:00+00:00</updated>
    <id>http://namshi.github.io/blog/2016/01/28/newsletter-number-123</id>
    <content type="html"><![CDATA[<blockquote><p>Hi there!</p>

<p>We are looking for <a href="/blog/2016/01/18/were-hiring-backend-ers/">backend software engineers</a>.</p>

<p>and here is your weekly dose of links</p>

<p>Enjoy!</p></blockquote>

<ul>
<li><p><a href="https://jakearchibald.com/2016/streams-ftw/">2016 &ndash; the year of web streams</a></p></li>
<li><p><a href="http://manuel.bernhardt.io/2015/11/13/5-years-of-scala-and-counting-debunking-some-myths-about-the-language-and-its-environment/?utm_source=hackernewsletter">5 years of scala and counting ‚Äì debunking some myths about the language and its environment </a></p></li>
<li><p><a href="https://camjackson.net/post/9-things-every-reactjs-beginner-should-know">9 things every react.js beginner should know &ndash; cam jackson</a></p></li>
<li><p><a href="http://jasonwilder.com/blog/2014/10/13/a-simple-way-to-dockerize-applications/">a simple way to dockerize applications ¬∑</a></p></li>
</ul>


<!-- more -->


<ul>
<li><p><a href="https://dev.windows.com/en-us/microsoft-edge/testdrive/demos/chess/?utm_source=hackernewsletter">asm.sj &ndash; chess </a></p></li>
<li><p><a href="https://github.com/mcollina/climem">climem: monitor the memory consumption of your node process via cli</a></p></li>
<li><p><a href="http://code.tutsplus.com/tutorials/creating-single-page-applications-with-wordpress-and-angularjs--cms-25095">creating single page applications with wordpress and angular.js &ndash; envato tuts code tutorial</a></p></li>
<li><p><a href="http://wesbos.com/css-highlight-animation">css highlight on hover animation | wes bos</a></p></li>
<li><p><a href="https://davehall.com.au/blog/dave/2016/01/19/internal-applications-when-semantic-versioning-doesnt-make-sense">internal applications: when semantic versioning doesn&rsquo;t make sense | dave hall consulting</a></p></li>
<li><p><a href="https://jamesmckay.net/2015/07/check-in-before-code-review-is-an-antipattern/">james mckay dot net ¬ª check-in before code review is an antipattern</a></p></li>
<li><p><a href="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces/">react and the economics of dynamic web interfaces &ndash; nczonline</a></p></li>
<li><p><a href="https://github.com/aerofs/react-native-auto-updater">reat native auto updater &ndash; a library to manage dynamic updates to react native apps</a></p></li>
<li><p><a href="http://importjake.io/testing-express-routes-with-mocha-supertest-and-mock-goose/">testing express routes with mocha, chai, supertest, and mockgoose</a></p></li>
<li><p><a href="https://m.signalvnoise.com/the-fidelity-curve-weighing-the-costs-and-benefits-of-interface-design-mockups-b259634807e2">the fidelity curve: how to weigh the costs and benefits of creating ui mockups ‚Äî signal v. noise ‚Äî medium</a></p></li>
<li><p><a href="http://www.infoq.com/presentations/7-sins-microservices">the seven deadly sins of microservices</a></p></li>
<li><p><a href="http://www.fastcompany.com/3053036/how-to-be-a-success-at-everything/the-simple-technique-to-fit-a-40-hour-work-week-into-167-h">the simple technique to fit a 40-hour workweek into 16.7 hours</a></p></li>
<li><p><a href="http://vorlonjs.com/">vorlon.js</a></p></li>
<li><p><a href="http://www.onegeek.com.au/articles/waiting-for-dependencies-in-docker-compose">waiting for dependencies in docker compose | web, apis </a></p></li>
<li><p><a href="https://medium.com/@stueccles/what-i-learned-migrating-a-rails-app-to-elixir-phoenix-f707436749aa">what i learned migrating a rails app to elixir/phoenix</a></p></li>
<li><p><a href="http://brolik.com/blog/when-to-use-flexbox/">when to use flexbox : the brolik blog</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Newsletter #118]]></title>
    <link href="http://namshi.github.io/blog/2015/12/17/newsletter-number-118/"/>
    <updated>2015-12-17T12:35:00+00:00</updated>
    <id>http://namshi.github.io/blog/2015/12/17/newsletter-number-118</id>
    <content type="html"><![CDATA[<blockquote><p>Hi there!</p>

<p>Today we will celabrate 4th <a href="https://www.namshi.com">Namshi</a>&rsquo;s birthday!</p>

<p>Thanks to all the people at Namshi! We&rsquo;ll share with you the party pictures next week! ;) In the meanwhile you&rsquo;ll get some really good links for the weekend!</p>

<p>Enjoy!!</p></blockquote>

<ul>
<li><p><a href="http://www.webondevices.com/9-javascript-apis-accessing-device-sensors/">9 javascript apis accessing device hardware</a></p></li>
<li><p><a href="https://github.com/ksimka/go-is-not-good?utm_content=buffer7ee07">a curated list of articles complaining that go (golang) isn&rsquo;t good enough</a></p></li>
<li><p><a href="http://nicolasgallagher.com/micro-clearfix-hack/">a new micro clearfix hack ‚Äì nicolas gallagher</a></p></li>
</ul>


<!-- more -->


<ul>
<li><p><a href="http://blog.ionic.io/announcing-ionic-1-2/?utm_content=bufferb1e74">announcing ionic 1.2 | the official ionic blog</a></p></li>
<li><p><a href="https://www.thoughtworks.com/insights/blog/bff-soundcloud">bff @ soundcloud | thoughtworks</a></p></li>
<li><p><a href="http://rmurphey.com/blog/2015/11/25/building-for-http2">building for http/2</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=LY65F2e4B5w">cssconf eu 2015 | una kravets: photoshop is dead!: editing images in css &ndash; youtube</a></p></li>
<li><p><a href="https://blackfire.io/docs/24-days/15-unit-tests">day 15 &ndash; integrating with unit tests &ndash; blackfire</a></p></li>
<li><p><a href="http://softwareengineeringdaily.com/2015/12/09/javascript-the-bad-parts-with-john-k-paul/">javascript: the bad parts with john k. paul &ndash; software engineering daily</a></p></li>
<li><p><a href="http://www.slideshare.net/yunongx/node-interactive-debugging-nodejs-in-production?utm_content=bufferf6678">node interactive debugging node.js in production</a></p></li>
<li><p><a href="https://www.outlearn.com/learn/matryer/golang-from-scratch/1">outlearn &mdash; learn go from scratch &mdash; why learn go?</a></p></li>
<li><p><a href="http://www.lottejackson.com/learning/be-comfortable-looking-like-an-idiot">public speaking: be comfortable looking like an idiot.</a></p></li>
<li><p><a href="http://rickbergfalk.github.io/sqlpad/">sqlpad &ndash; a web app for running sql queries and visualizing the results</a></p></li>
<li><p><a href="https://medium.com/development-musings/the-7d-s-of-development-what-they-don-t-teach-you-at-code-school-6c58c1ba0fc5">the 7d‚Äôs of development what they don‚Äôt teach you at code school </a></p></li>
<li><p><a href="http://www.bloomberg.com/features/2015-george-hotz-self-driving-car/">the first person to hack the iphone built a self-driving car. in his garage</a></p></li>
<li><p><a href="http://rejected.us/">they rejected us.</a></p></li>
<li><p><a href="https://github.com/uber/ringpop-node?utm_content=bufferfccb6">uber/ringpop-node</a></p></li>
<li><p><a href="https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">why gnu grep is fast</a></p></li>
<li><p><a href="https://www.nczonline.net/blog/2015/12/why-im-not-using-your-open-source-project/">why i&rsquo;m not using your open source project</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
